/* --------------------------------------------------------------------------------
 #
 #  4DPlugin-xmlsec.cpp
 #	source generated by 4D Plugin Wizard
 #	Project : xmlsec
 #	author : miyako
 #	2021/05/18
 #  
 # --------------------------------------------------------------------------------*/

#include "4DPlugin-xmlsec.h"

#pragma mark -

static void __Startup() {
        
    xmlInitParser();//<->xmlCleanupParser();
    xsltInit();
    
    xmlLoadExtDtdDefaultValue = XML_DETECT_IDS | XML_COMPLETE_ATTRS;
    xmlSubstituteEntitiesDefault(1);
    xmlIndentTreeOutput = 1;//xmlGlobalState
}

static void OnStartup() {
    
#ifdef VERSIONWIN
    PA_RunInMainProcess((PA_RunInMainProcessProcPtr)__Startup, NULL);
#else
    __Startup();
#endif
}

static void __Exit() {

    xsltCleanupGlobals();
    xmlCleanupParser();//<->xmlInitParser();
}

static void OnExit() {
    
#ifdef VERSIONWIN
    PA_RunInMainProcess((PA_RunInMainProcessProcPtr)__Exit, NULL);
#else
    __Exit();
#endif
}

#pragma mark -

void PluginMain(PA_long32 selector, PA_PluginParameters params) {
    
	try
	{
        switch(selector)
        {
            case kInitPlugin :
            case kServerInitPlugin :
                OnStartup();
                break;
                
            case kDeinitPlugin :
            case kServerDeinitPlugin :
                OnExit();
                break;
                
			// --- xmlsec
            
			case 1 :
				xmlsec_sign(params);
				break;
			case 2 :
				xmlsec_verify(params);
				break;
			case 3 :
				xmlsec_encrypt(params);
				break;
			case 4 :
				xmlsec_decrypt(params);
				break;

        }

	}
	catch(...)
	{

	}
}

#pragma mark -

static xmlSecKeyPtr loadKey(PA_ObjectRef options, C_BLOB& Param2, xmlSecKeyDataFormat fmt) {
    
    xmlString password;
    
    CUTF8String textValue;
    if(ob_get_s(options, L"password", &textValue)) {
        password = (const xmlChar *)textValue.c_str();
    }
    
    return xmlSecCryptoAppKeyLoadMemory((const xmlSecByte *)Param2.getBytesPtr(),
                                        (xmlSecSize)Param2.getBytesLength(),
                                        fmt,
                                        password.length() ? (const char *)password.c_str() : NULL,
                                        NULL, NULL);
}

static int loadCert(xmlSecKeyPtr key, C_BLOB& Param3, xmlSecKeyDataFormat fmt) {
        
    return xmlSecOpenSSLAppKeyCertLoadMemory(key,
                                             (const xmlSecByte *)Param3.getBytesPtr(),
                                             (xmlSecSize)Param3.getBytesLength(),
                                             fmt);
}

static xmlDocPtr parseXml(PA_ObjectRef options, const wchar_t *key) {
    
    xmlDocPtr p = NULL;
    
    CUTF8String xml;
    if(ob_get_s(options, key, &xml)) {
        p = xmlParseDoc((const xmlChar *)xml.c_str());
    }
    
    if(p == NULL) {
#if VERSIONMAC
        NSString *str = [[NSString alloc]initWithUTF8String:(const char *)xml.c_str()];
        if(str) {
            NSURL *url = (NSURL *)CFURLCreateWithFileSystemPath(kCFAllocatorDefault,
                                                                (CFStringRef)str, kCFURLHFSPathStyle, false);
            if(url) {
                NSString *path = (NSString *)CFURLCopyFileSystemPath((CFURLRef)url, kCFURLPOSIXPathStyle);
                if(path) {
                    p = xmlParseFile((const char *)[path UTF8String]);
                    [path release];
                }
                [url release];
            }
            [str release];
        }
#else
        p = xmlParseFile((const char *)xml.c_str());
#endif
    }
 
    return p;
}

static xsltSecurityPrefsPtr createSecurityPrefs() {
    
    xsltSecurityPrefsPtr xsltSecPrefs = xsltNewSecurityPrefs();
    
    /* disable everything */
    xsltSetSecurityPrefs(xsltSecPrefs,  XSLT_SECPREF_READ_FILE,        xsltSecurityForbid);
    xsltSetSecurityPrefs(xsltSecPrefs,  XSLT_SECPREF_WRITE_FILE,       xsltSecurityForbid);
    xsltSetSecurityPrefs(xsltSecPrefs,  XSLT_SECPREF_CREATE_DIRECTORY, xsltSecurityForbid);
    xsltSetSecurityPrefs(xsltSecPrefs,  XSLT_SECPREF_READ_NETWORK,     xsltSecurityForbid);
    xsltSetSecurityPrefs(xsltSecPrefs,  XSLT_SECPREF_WRITE_NETWORK,    xsltSecurityForbid);
    xsltSetDefaultSecurityPrefs(xsltSecPrefs);
        
    return xsltSecPrefs;
}

static xmlNodePtr getSignatureNode(xmlDocPtr doc) {
    
    xmlNodePtr node = NULL;
    
    xmlNodePtr rootNode = xmlDocGetRootElement(doc);
    if(rootNode) {
        node = xmlSecFindNode(rootNode, xmlSecNodeSignature, xmlSecDSigNs);
    }
    
    return node;
}

static xmlNodePtr findNode(PA_ObjectRef options, xmlDocPtr doc) {
    
    xmlNodePtr node = NULL;
    
    if(options) {
                
        CUTF8String textValue;
        
        //find node with id=id
        if(ob_get_s(options, L"id", &textValue)) {
            xmlAttrPtr attr = xmlGetID(doc, BAD_CAST textValue.c_str());
            if(attr) {
                node = attr->parent;
                if(node) {
                    return node;
                }
            }
        }

        //find node with name=node
        if(ob_get_s(options, L"node", &textValue)) {
            xmlChar *buf = xmlStrdup(BAD_CAST textValue.c_str());
            if(buf) {
                xmlChar *name;
                xmlChar *ns;
                name = (xmlChar *)strrchr((char *)buf, ':');
                if(name != NULL) {
                    (*(name++)) = '\0';
                    ns = buf;
                } else {
                    name = buf;
                    ns = NULL;
                }
                
                node = xmlSecFindNode(xmlDocGetRootElement(doc), name, ns);
                
                xmlFree(buf);
                
                if(node) {
                    return node;
                }
            }
        }
        
        if(ob_get_s(options, L"xpath", &textValue)) {
            xmlNodePtr rootNode = xmlDocGetRootElement(doc);
            if(rootNode) {
                xmlXPathContextPtr ctx = xmlXPathNewContext(doc);
                if(ctx) {
                    xmlNsPtr ns;
                    for(ns = rootNode->nsDef; ns != NULL; ns = ns->next) {
                        if(ns->prefix != NULL){
                            xmlXPathRegisterNs(ctx, ns->prefix, ns->href);
                        }
                    }
                    xmlXPathObjectPtr obj = xmlXPathEval(BAD_CAST textValue.c_str(), ctx);
                    if(obj) {
                        if((obj->nodesetval) && (obj->nodesetval->nodeNr == 1)) {
                            node = obj->nodesetval->nodeTab[0];
                        }
                        xmlXPathFreeObject(obj);
                    }
                    xmlXPathFreeContext(ctx);
                    if(node) {
                        return node;
                    }
                }
            }
        }
          
    }
    
    return getSignatureNode(doc);
}

static xmlSecKeyDataFormat getFmt(PA_ObjectRef options, const wchar_t *key) {
    
    xmlSecKeyDataFormat fmt = xmlSecKeyDataFormatPem;
    
    CUTF8String textValue;
    if(ob_get_s(options, L"key", &textValue)) {
        if(textValue == (const uint8_t *)"binary") {
            fmt = xmlSecKeyDataFormatBinary;
        }else
        if(textValue == (const uint8_t *)"pem") {
            fmt = xmlSecKeyDataFormatPem;
        }else
        if(textValue == (const uint8_t *)"der") {
            fmt = xmlSecKeyDataFormatDer;
        }else
        if(textValue == (const uint8_t *)"pkcs8pem") {
            fmt = xmlSecKeyDataFormatPkcs8Pem;
        }else
        if(textValue == (const uint8_t *)"pkcs8der") {
            fmt = xmlSecKeyDataFormatPkcs8Der;
        }else
        if(textValue == (const uint8_t *)"pkcs12") {
            fmt = xmlSecKeyDataFormatPkcs12;
        }else
        if(textValue == (const uint8_t *)"pemcert") {
            fmt = xmlSecKeyDataFormatCertPem;
        }else
        if(textValue == (const uint8_t *)"dercert") {
            fmt = xmlSecKeyDataFormatCertDer;
        }
    }
    
    return fmt;
}

static void verify_result(PA_ObjectRef status, xmlSecDSigCtxPtr pDsigCtx) {
    
    ob_set_b(status, L"success", true);
    
    //bug? should be pDsigCtx->status;
    
    xmlSecDSigStatus stat = static_cast<xmlSecDSigStatus>(reinterpret_cast<size_t>(pDsigCtx->signMethod));

    if(stat ==  xmlSecDSigStatusSucceeded) {
        ob_set_b(status, L"valid", true);
    }else{
        ob_set_b(status, L"valid", false);
    }

}

static void sign_result(PA_ObjectRef status, xmlDocPtr doc) {
    
    xmlChar *xml = NULL;
    int len = 0;
    
    xmlDocDumpFormatMemoryEnc(doc, &xml, &len, "UTF-8", 1);
    if(xml) {
        if(len) {
            CUTF8String result = CUTF8String((const uint8_t *)xml, (size_t)len);
            ob_set_s(status, L"xml", (const char *)result.c_str());
            ob_set_b(status, L"success", true);
        }else{
            ob_set_s(status, L"error", (const char *)"failed:xmlOutputBufferGetSize");
        }
        xmlFree(xml);
    }
}

static void doIt(PA_PluginParameters params, xmlsec_command_t command, int cb(xmlSecDSigCtxPtr dsigCtx, xmlNodePtr node)) {
    
    PA_ObjectRef options = PA_GetObjectParameter(params, 1);
    PA_ObjectRef status  = PA_CreateObject();
    
    const xmlChar *crypto = xmlSecGetDefaultCrypto();
    ob_set_s(status, L"crypto", (const char *)crypto);
    
    ob_set_b(status, L"success", false);
    
    PackagePtr pParams = (PackagePtr)params->fParameters;
    
    C_BLOB Param2;
    Param2.fromParamAtIndex(pParams, 2);//key
    
    C_BLOB Param3;
    Param3.fromParamAtIndex(pParams, 3);//x509 cert
    
    xsltSecurityPrefsPtr xsltSecPrefs = createSecurityPrefs();
    
    if(xmlSecCryptoAppInit(NULL) == 0) {
        if(xmlSecInit() == 0) {
            if(xmlSecCryptoInit() == 0) {
                
                xmlDocPtr doc = NULL;
                xmlSecKeyDataFormat keyFmt = xmlSecKeyDataFormatPem;
                xmlSecKeyDataFormat crtFmt = xmlSecKeyDataFormatPem;
                
                xmlString name;//->xmlSecKeySetName
                
                bool ignoreManifests = false;
                bool storeReferences = false;
                bool storeSignatures = false;
                bool enableVisa3DHack = false;
                
                bool signTmpl = false;
                
                if(options) {
                    
                    keyFmt = getFmt(options, L"key");
                    crtFmt = getFmt(options, L"cert");
                    
                    CUTF8String textValue;
                    
                    if(ob_get_s(options, L"name", &textValue)) {
                        name = (const xmlChar *)textValue.c_str();
                    }
                    
                    if(ob_is_defined(options, L"ignoreManifests")) {
                        ignoreManifests = ob_get_b(options, L"ignoreManifests");
                    }
                    
                    if(ob_is_defined(options, L"storeReferences")) {
                        storeReferences = ob_get_b(options, L"storeReferences");
                    }
                    
                    if(ob_is_defined(options, L"storeSignatures")) {
                        storeSignatures = ob_get_b(options, L"storeSignatures");
                    }
                    
                    if(ob_is_defined(options, L"enableVisa3DHack")) {
                        enableVisa3DHack = ob_get_b(options, L"enableVisa3DHack");
                    }
                    
                    if(ob_is_defined(options, L"tmpl")) {
                        signTmpl = ob_get_b(options, L"tmpl");
                    }
                    
                    doc = parseXml(options, L"xml");
                    
                }
                
                if(doc) {
                    
                    if(signTmpl) {
                        /* create signature template for RSA-SHA1 enveloped signature */
                        xmlNodePtr signNode = xmlSecTmplSignatureCreate(doc,
                                                                        xmlSecTransformExclC14NId,
                                                                        xmlSecTransformRsaSha1Id,
                                                                        NULL);
                        if(signNode) {
                            //<dsig:Signature/>
                            xmlNodePtr childNode = xmlAddChild(xmlDocGetRootElement(doc), signNode);
                            if(childNode) {
                                
                            }else{
                                ob_set_s(status, L"error", (const char *)"failed:xmlAddChild");
                            }
                            
                            xmlNodePtr refNode = xmlSecTmplSignatureAddReference(signNode,
                                                                                 xmlSecTransformSha1Id,
                                                                                 NULL, NULL, NULL);
                            if(refNode) {
                                if(xmlSecTmplReferenceAddTransform(refNode, xmlSecTransformEnvelopedId)) {
                                    //<dsig:KeyInfo/> and <dsig:KeyName/>
                                    xmlNodePtr keyInfoNode = xmlSecTmplSignatureEnsureKeyInfo(signNode, NULL);
                                    if(keyInfoNode) {
                                        if(Param3.getBytesLength()) {
                                            xmlNodePtr x509DataNode = xmlSecTmplKeyInfoAddX509Data(keyInfoNode);
                                            if(x509DataNode) {
                                                if(xmlSecTmplX509DataAddSubjectName(x509DataNode)) {
                                                    if(xmlSecTmplX509DataAddCertificate(x509DataNode)) {
                                                    
                                                    }else{
                                                        ob_set_s(status, L"error", (const char *)"failed:xmlSecTmplX509DataAddCertificate");
                                                    }
                                                }else{
                                                    ob_set_s(status, L"error", (const char *)"failed:xmlSecTmplX509DataAddSubjectName");
                                                }
                                            }else{
                                                ob_set_s(status, L"error", (const char *)"failed:xmlSecTmplKeyInfoAddX509Data");
                                            }
                                        }else{
                                            if(xmlSecTmplKeyInfoAddKeyName(keyInfoNode, NULL)) {
                                                
                                            }else{
                                                ob_set_s(status, L"error", (const char *)"failed:xmlSecTmplKeyInfoAddKeyName");
                                            }
                                        }
                                    }else{
                                        ob_set_s(status, L"error", (const char *)"failed:xmlSecTmplSignatureEnsureKeyInfo");
                                    }
                                }else{
                                    ob_set_s(status, L"error", (const char *)"failed:xmlSecTmplReferenceAddTransform");
                                }
                            }else{
                                ob_set_s(status, L"error", (const char *)"failed:xmlSecTmplSignatureAddReference");
                            }
                        }else{
                            ob_set_s(status, L"error", (const char *)"failed:xmlSecTmplSignatureCreate");
                        }
                    }
                    
                    xmlNodePtr node = getSignatureNode(doc);
                    xmlSecKeyPtr secKey = NULL;
                    xmlSecDSigCtxPtr pDsigCtx = NULL;
                    
                    if(node) {
                        
                        xmlSecKeysMngrPtr keysMngr = xmlSecKeysMngrCreate();
                        
                        if(keysMngr) {
                            
                            if(xmlSecCryptoAppDefaultKeysMngrInit(keysMngr) == 0) {
                                
                                if(Param2.getBytesLength()) {
                                    
                                    secKey = loadKey(options, Param2, keyFmt);
                                    
                                    if(secKey) {
                                        
                                        if(name.length()) {
                                            if(xmlSecKeySetName(secKey, name.c_str()) != 0) {
                                                ob_set_s(status, L"error", (const char *)"failed:xmlSecKeySetName");
                                            }
                                        }
                                        if(xmlSecCryptoAppDefaultKeysMngrAdoptKey(keysMngr, secKey) == 0){
                                            
                                        }else{
                                            ob_set_s(status, L"error", (const char *)"failed:xmlSecCryptoAppDefaultKeysMngrAdoptKey");
                                        }
                                    }else{
                                        ob_set_s(status, L"error", (const char *)"failed:xmlSecCryptoAppKeyLoadMemory");
                                    }
                                    
                                    if(Param3.getBytesLength()) {
                                        
                                        if(loadCert(secKey, Param3, crtFmt)==0) {
                                            
                                        }else{
                                            ob_set_s(status, L"error", (const char *)"failed:xmlSecOpenSSLAppKeyCertLoadMemory");
                                        }
                                        
                                    }
                                    
                                }
                                
                                pDsigCtx = xmlSecDSigCtxCreate(keysMngr);

                                if(pDsigCtx) {
                                    
                                    if(command == xmlsec_command_verify) {
                                    }
                                    
                                    
                                    if(command == xmlsec_command_verify) {
                                        
                                        /* limit the Reference URI attributes to empty or NULL */
                                        pDsigCtx->enabledReferenceUris = xmlSecTransformUriTypeEmpty;
                                        
                                        /* limit allowed transforms for signature and reference processing */
                                        if(   (xmlSecDSigCtxEnableSignatureTransform(pDsigCtx, xmlSecTransformInclC14NId) == 0)
                                           && (xmlSecDSigCtxEnableSignatureTransform(pDsigCtx, xmlSecTransformExclC14NId) == 0)
                                           && (xmlSecDSigCtxEnableSignatureTransform(pDsigCtx, xmlSecTransformSha1Id) == 0)
                                           && (xmlSecDSigCtxEnableSignatureTransform(pDsigCtx, xmlSecTransformRsaSha1Id) == 0)) {
                                            
                                        }
                                        if(   (xmlSecDSigCtxEnableReferenceTransform(pDsigCtx, xmlSecTransformInclC14NId) == 0)
                                           && (xmlSecDSigCtxEnableReferenceTransform(pDsigCtx, xmlSecTransformExclC14NId) == 0)
                                           && (xmlSecDSigCtxEnableReferenceTransform(pDsigCtx, xmlSecTransformSha1Id) == 0)
                                           && (xmlSecDSigCtxEnableReferenceTransform(pDsigCtx, xmlSecTransformEnvelopedId) == 0)) {
                                            
                                        }
                                        
                                        /* in addition, limit possible key data to valid X509 certificates only */
                                        if(xmlSecPtrListAdd(&(pDsigCtx->keyInfoReadCtx.enabledKeyData), BAD_CAST xmlSecKeyDataX509Id) == 0) {
                                            
                                        }
                                    }
                                        
                                    //--ignore-manifests
                                    if(ignoreManifests) {
                                        pDsigCtx->flags |= XMLSEC_DSIG_FLAGS_IGNORE_MANIFESTS;
                                    }
                                    
                                    //--store-references
                                    if(storeReferences) {
                                        pDsigCtx->flags |= XMLSEC_DSIG_FLAGS_STORE_SIGNEDINFO_REFERENCES |
                                        XMLSEC_DSIG_FLAGS_STORE_MANIFEST_REFERENCES;
                                    }
                                    
                                    //--store-signatures
                                    if(storeSignatures) {
                                        pDsigCtx->flags |= XMLSEC_DSIG_FLAGS_STORE_SIGNATURE;
                                    }
                                    
                                    //--enable-visa3d-hack
                                    if(enableVisa3DHack) {
                                        pDsigCtx->flags |= XMLSEC_DSIG_FLAGS_USE_VISA3D_HACK;
                                    }
                                        
                                    switch (command) {
                                        case xmlsec_command_sign:
                                            if(cb(pDsigCtx, node) == 0) {
                                                sign_result(status, doc);
                                            }else{
                                                ob_set_s(status, L"error", (const char *)"failed:xmlSecDSigCtxSign");
                                            }
                                            break;
                                        case xmlsec_command_verify:
                                            if(cb(pDsigCtx, node) == 0) {
                                                verify_result(status, pDsigCtx);
                                            }else{
                                                ob_set_s(status, L"error", (const char *)"failed:xmlSecDSigCtxVerify");
                                            }
                                            break;
                                        case xmlsec_command_encrypt:
                                            
                                            break;
                                        case xmlsec_command_decrypt:
                                            
                                            break;
                                        default:
                                            break;
                                    }
                                    
                                    xmlSecDSigCtxDestroy (pDsigCtx);
                                }else{
                                    ob_set_s(status, L"error", (const char *)"failed:xmlSecDSigCtxCreate");
                                }
                            }
                            xmlSecKeysMngrDestroy(keysMngr);
                        }else{
                            ob_set_s(status, L"error", (const char *)"failed:xmlSecKeysMngrCreate");
                        }
                    }else{
                        ob_set_s(status, L"error", (const char *)"failed:xmlSecFindNode:xmlSecNodeSignature:xmlSecDSigNs");
                    }
                    xmlFreeDoc(doc);
                }else{
                    ob_set_s(status, L"error", (const char *)"failed:xmlParseDoc");
                }
                xmlSecCryptoShutdown();
            }
            xmlSecShutdown();
        }
        xmlSecCryptoAppShutdown();
    }
    
    xsltFreeSecurityPrefs(xsltSecPrefs);
    
    PA_ReturnObject(params, status);
}

#pragma mark -

static void xmlsec_sign(PA_PluginParameters params) {
    
    doIt(params, xmlsec_command_sign, xmlSecDSigCtxSign);
    
}

void xmlsec_verify(PA_PluginParameters params) {

    doIt(params, xmlsec_command_verify, xmlSecDSigCtxVerify);
    
}

void xmlsec_encrypt(PA_PluginParameters params) {

}

void xmlsec_decrypt(PA_PluginParameters params) {

}

